from decimal import Decimal
from uuid import UUID, uuid4

from django.db import transaction as db_transaction

from apps.account.exceptions import SameWalletException, WalletNotFoundError
from apps.account.models import Wallet
from apps.account.services.transaction import TransactionService
from apps.common.exceptions import BalanceNegativeError


class WalletService:
    """
    Service for wallet-related operations such as applying cash flows
    and transferring funds between wallets, enforcing business rules
    like preventing negative balances.

    All operations are performed atomically to maintain data consistency.
    """

    @classmethod
    def apply_cash_flow(cls, wallet_id: str, amount: Decimal, txid: str = None):
        """
        Applies a cash flow operation to a wallet (e.g., deposit or withdrawal).

        This method locks the wallet row for update to prevent race conditions,
        validates that the wallet balance will not become negative,
        and creates a corresponding Transaction record.

        Args:
            wallet_id (str): UUID of the wallet.
            amount (Decimal): Amount to add (positive) or subtract (negative).
            txid (str, optional): Unique transaction ID; autogenerated if omitted.

        Returns:
            Transaction: Created transaction with deposited amount.

        Raises:
            BalanceNegativeError: If applying the amount results in negative balance.
            Wallet.DoesNotExist: If the wallet does not exist.
        """
        with db_transaction.atomic():
            try:
                wallet = Wallet.objects.select_for_update().get(id=wallet_id)
            except Wallet.DoesNotExist:
                raise WalletNotFoundError(wallet_id)
            cls._validate_balance(wallet, amount)

            return TransactionService.create(
                wallet=wallet,
                amount=amount,
                txid=txid or uuid4().hex,
            )

    @classmethod
    def transfer(cls, source_id: str, dest_id: str, amount: Decimal):
        """
        Transfers funds between two wallets by creating offsetting transactions.

        Locks both wallets for update to prevent concurrent modifications.
        Validates that the source wallet has sufficient funds before proceeding.

        Args:
            source_id (str): UUID of the source wallet.
            dest_id (str): UUID of the destination wallet.
            amount (Decimal): Positive amount to transfer.

        Returns:
            Tuple[Wallet, Wallet]: Updated source and destination wallet instances.

        Raises:
            BalanceNegativeError: If amount is not positive or insufficient funds.
            NotFound: if one or both wallets not found
        """
        if amount <= 0:
            raise BalanceNegativeError("Transfer amount must be positive")
        if source_id == dest_id:
            raise SameWalletException

        source_uuid = UUID(source_id)
        dest_uuid = UUID(dest_id)
        with db_transaction.atomic():
            found_wallets = Wallet.objects.select_for_update().in_bulk([source_id, dest_id])
            source = found_wallets.get(source_uuid)
            dest = found_wallets.get(dest_uuid)

            missing = [
                str(w_id) for w_id, wallet in [(source_id, source), (dest_id, dest)] if not wallet
            ]
            if missing:
                raise WalletNotFoundError(missing)

            source = found_wallets[source_uuid]
            dest = found_wallets[dest_uuid]

            cls._validate_balance(source, amount)

            TransactionService.create(
                wallet=source,
                amount=amount.copy_negate(),
                txid=uuid4().hex,
            )
            TransactionService.create(
                wallet=dest,
                amount=amount,
                txid=uuid4().hex,
            )

            return source, dest

    @staticmethod
    def _validate_balance(wallet: Wallet, delta: Decimal):
        """
        Validates that the wallet balance will not become negative after applying delta.

        Args:
            wallet (Wallet): The wallet instance to check.
            delta (Decimal): The amount to apply (positive or negative).

        Raises:
            BalanceNegativeError: If the resulting balance would be negative.
        """
        new_balance = wallet.balance + delta
        if new_balance < 0:
            raise BalanceNegativeError("Insufficient wallet funds")
